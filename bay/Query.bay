/*!
 *  Bayrell Runtime Library
 *
 *  (c) Copyright 2016-2021 "Ildar Bikmamatov" <support@bayrell.org>
 *
 *  Licensed under the Apache License, Version 2.0 (the "License");
 *  you may not use this file except in compliance with the License.
 *  You may obtain a copy of the License at
 *
 *      https://www.apache.org/licenses/LICENSE-2.0
 *
 *  Unless required by applicable law or agreed to in writing, software
 *  distributed under the License is distributed on an "AS IS" BASIS,
 *  WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 *  See the License for the specific language governing permissions and
 *  limitations under the License.
 */

namespace Runtime.ORM;

use Runtime.lib;
use Runtime.BaseStruct;
use Runtime.ORM.Annotations.Primary;
use Runtime.ORM.Connection;
use Runtime.ORM.Cursor;
use Runtime.ORM.Driver;
use Runtime.ORM.Helper;
use Runtime.ORM.QueryFilter;
use Runtime.ORM.Record;
use Runtime.ORM.StructBuilder;


struct Query extends BaseStruct
{
	static const string QUERY_RAW = "raw";
	static const string QUERY_SELECT = "select";
	static const string QUERY_INSERT = "insert";
	static const string QUERY_UPDATE = "update";
	static const string QUERY_DELETE = "delete";
	static const string QUERY_INSERT_OR_UPDATE = "insert_or_update";
	static const string BUILD_TABLE_STRUCT_CHAIN = "Runtime.ORM.BuildStruct";
	
	string _object_name = "";
	string _kind = "";
	string _table_name = "";
	string _table_name_alias = "";
	Collection<string> _fields = null;
	Collection<Dict> _join = null;
	Collection<Collection<string>> _order = null;
	Collection<QueryFilter> _filter = null;
	int _start = 0;
	int _limit = -1;
	bool _as_record = true;
	bool _calc_found_rows = false;
	bool _log = false;
	string _sql = "";
	Dict _params = {};
	
	
	
	/**
	 * Calc found rows
	 */
	Query raw(string sql, Dict params) =>
		this.copy
		{
			"_kind": static::QUERY_RAW,
			"_sql": sql,
			"_params": params,
		}
	;
	
	
	
	/**
	 * Calc found rows
	 */
	Query calcFoundRows(bool value = true) =>
		this.copy
		{
			"_calc_found_rows": value,
		}
	;
	
	
	
	/**
	 * Select query
	 */
	Query orm(string class_name) =>
		this.copy
		{
			"_object_name": class_name,
		}
	;
	
	
	
	/**
	 * Set alias
	 */
	Query alias(string alias_name) =>
		this.copy
		{
			"_table_name_alias": alias_name,
		}
	;
	
	
	
	/**
	 * Set debug log
	 */
	Query debug(bool value) =>
		this.copy
		{
			"_log": value,
		}
	;
	
	
	
	/**
	 * Select query
	 */
	Query select(string table_name, string alias_name = "") =>
		this.copy
		{
			"_kind": static::QUERY_SELECT,
			"_fields": ["*"],
			"_table_name": table_name,
			"_table_name_alias": alias_name,
		}
	;
	
	
	
	/**
	 * Select objects
	 */
	Query selectObjects(string object_name, string alias_name = "")
	{
		Helper helper = @.getDriver(classof Helper);
		StructBuilder builder = helper.tables.get(object_name, null);
		
		return this.copy
		{
			"_kind": static::QUERY_SELECT,
			"_fields": ["*"],
			"_table_name": (builder != null) ? builder.table_name : "",
			"_object_name": object_name,
			"_table_name_alias": alias_name,
		}
	}
	
	
	
	/**
	 * Set fields
	 */
	Query fields(Collection fields) =>
		this.copy
		{
			"_fields": fields,
		}
	;
	
	
	
	/**
	 * Add page
	 */
	Query page(int page, int limit) =>
		this.copy
		{
			"_start": page * limit,
			"_limit": limit,
		}
	;
	
	
	
	/**
	 * Set offset
	 */
	Query offset(int start, int limit) =>
		this.copy
		{
			"_start": start,
			"_limit": limit,
		}
	;
	
	
	
	/**
	 * Set start
	 */
	Query start(int start) =>
		this.copy
		{
			"_start": start,
		}
	;
	
	
	
	/**
	 * Set limit
	 */
	Query limit(int limit) =>
		this.copy
		{
			"_limit": limit,
		}
	;
	
	
	
	/**
	 * Set order
	 */
	Query order(Collection<Collection<string>> order) =>
		this.copy
		{
			"_order": order,
		}
	;
	
	
	
	/**
	 * Add order
	 */
	Query addOrder(string field_name, string order) =>
		this.copy
		{
			"_order": this._order != null ? this._order.pushIm([field_name, order]) : [ [field_name, order] ]
		}
	;
	
	
	
	/**
	 * Add filter
	 */
	Query setFilter(Collection<QueryFilter> filter) =>
		this.copy
		{
			"_filter": filter,
		}
	;
	
	
	
	/**
	 * Add filter
	 */
	Query prependFilter(QueryFilter filter) =>
		this.copy
		{
			"_filter": this._filter != null ? this._filter.prependIm(filter) : [ filter ]
		}
	;
	
	
	
	/**
	 * Add filter
	 */
	Query appendFilter(QueryFilter filter) =>
		this.copy
		{
			"_filter": this._filter != null ? this._filter.appendIm(filter) : [ filter ]
		}
	;
	
	
	
	/**
	 * Add filter
	 */
	Query addFilter(QueryFilter filter) => this.appendFilter(filter);
	
	
	
	/**
	 * Add filter
	 */
	pure QueryFilter filter(string field_name, string op, primitive value) =>
		new QueryFilter
		{
			"field_name": field_name,
			"op": op,
			"value": value,
		}
	;
	
	
	
	/**
	 * Inner join
	 */
	Query innerJoin(string table_name, string alias_name, string where)
	{
		Dict join =
		{
			"kind": "inner",
			"table_name": table_name,
			"alias_name": alias_name,
			"where": where,
		};
		return this.copy
		{
			"_join": this._join != null ? this._join.pushIm(join) : [ join ]
		}
	}
	
	
	
	/**
	 * Left join
	 */
	Query leftJoin(string table_name, string alias_name, string where)
	{
		Dict join =
		{
			"kind": "left",
			"table_name": table_name,
			"alias_name": alias_name,
			"where": where,
		};
		return this.copy
		{
			"_join": this._join != null ? this._join.pushIm(join) : [ join ]
		}
	}
	
	
	
	/**
	 * Get connection
	 */
	static async Connection connect(Dict db_settings = null)
	{
		string driver_name = db_settings["driver"] |> default string classof Driver;
		Driver orm = @.getDriver(driver_name);
		Connection conn = await orm.connect(db_settings);
		return conn;
	}
	
	
	
	/**
	 * Execute query
	 */
	async Cursor execute(Dict db_settings = null)
	{
		Connection conn = await static::connect(db_settings);
		Cursor cursor = await conn.executeQuery(this, db_settings);
		return cursor;
	}
	
	
	
	/**
	 * Fetch one
	 */
	async Dict one(Dict db_settings = null)
	{
		Cursor cursor = await this.execute(db_settings);
		Dict item = await cursor.fetchOne();
		await cursor.close();
		
		if (item != null) item = this.fromDatabase(cursor.getConnection(), item);
		
		return item;
	}
	
	
	
	/**
	 * Fetch one record
	 */
	async Dict oneRecord(Dict db_settings = null)
	{
		Dict item = await this.one(db_settings);
		if (item == null)
		{
			return null;
		}
		
		/* Find builder */
		Helper helper = @.getDriver(classof Helper);
		StructBuilder builder = helper.tables.get(this._object_name, null);
		if (builder == null)
		{
			return null;
		}
		
		/* Create record */
		string class_name = builder.class_name;
		Record object = rtl::newInstance(class_name);
		object.old_item = item;
		object.item = item;
		
		return object;
	}
	
	
	
	/**
	 * Fetch all
	 */
	async Dict all(Dict db_settings = null)
	{
		Cursor cursor = await this.execute(db_settings);
		Collection<Dict> items = await cursor.fetchAll();
		await cursor.close();
		
		items = items.map
		(
			Dict (Dict item) use (cursor) => this.fromDatabase(cursor.getConnection(), item)
		);
		
		return items;
	}
	
	
	
	/**
	 * Fetch all records
	 */
	async Dict allRecords(Dict db_settings = null)
	{
		return null;
	}
	
	
	
	/**
	 * Returns sql
	 */
	async Cursor getSQL(Dict db_settings = null)
	{
		Connection conn = await static::connect(db_settings);
		
		list res = conn.getQuerySQL(this);
		
		string sql = res[0];
		sql = rs::replace("${prefix}", conn.settings.prefix, sql);
		
		Dict params = res[1];
		Collection keys = params.keys();
		for (int i=0; i<keys.count(); i++)
		{
			string key = keys[i];
			sql = rs::replace(":" ~ key, "'" ~ params[key] ~ "'", sql);
		}
		
		return sql;
	}
	
	
	
	/**
	 * Get diff
	 */
	static Dict getDiff(Dict old_item, Dict update_item)
	{
		Map res = new Map();
		
		Collection keys = update_item.keys();
		for (int i=0; i<keys.count(); i++)
		{
			string field_name = keys[i];
			var new_value = update_item[field_name];
			if (old_item.has(field_name))
			{
				if (old_item[field_name] != new_value)
				{
					res.setValue(field_name, new_value);
				}
			}
			else
			{
				res.setValue(field_name, new_value);
			}
		}
		
		return res.toDict();
	}
	
	
	
	/**
	 * Filter row
	 */
	static Dict filterRow(string object_name, Dict row, string action = "")
	{
		Helper helper = @.getDriver(classof Helper);
		
		/* Find builder */
		StructBuilder builder = helper.tables.get(object_name, null);
		if (builder == null)
		{
			return {};
		}
		
		/* Update item */
		Collection keys = row.keys();
		for (int i=0; i<keys.count(); i++)
		{
			string field_name = keys[i];
			if (not builder.fields.has(field_name))
			{
				row = row.removeIm(field_name);
			}
		}
		
		return row;
	}
	
	
	
	/**
	 * Insert row
	 */
	static async Cursor insert(string table_name, Dict row, Dict db_settings)
	{
		Connection conn = await static::connect(db_settings);
		Cursor cursor = await conn.insert(table_name, row, db_settings);
		return cursor;
	}
	
	
	
	/**
	 * Update row
	 */
	static async Cursor update(string table_name, Collection<QueryFilter> filter, Dict row, Dict db_settings = null)
	{
		Connection conn = await static::connect(db_settings);
		Cursor cursor = await conn.update(table_name, filter, row, db_settings);
		return cursor;
	}
	
	
	
	/**
	 * Delete row
	 */
	static async Cursor delete(string table_name, Collection<QueryFilter> filter, Dict db_settings = null)
	{
		Connection conn = await static::connect(db_settings);
		Cursor cursor = await conn.delete(table_name, filter, db_settings);
		return cursor;
	}
	
	
	
	/**
	 * Insert object
	 */
	static async Cursor insertObject(string object_name, Dict row, Dict db_settings = null)
	{
		Helper helper = @.getDriver(classof Helper);
		
		/* Find builder */
		StructBuilder builder = helper.tables.get(object_name, null);
		if (builder == null)
		{
			return null;
		}
		
		/* Filter row */
		row = static::filterRow( object_name, row, "insert" );
		
		/* To database */
		row = static::toDatabase( object_name, row, db_settings );
		
		/* Insert row */
		Cursor cursor = await static::insert(builder.table_name, row, db_settings);
		return cursor;
	}
	
	
	
	/**
	 * Update object
	 */
	static async Cursor updateObject(string object_name, Dict pk, Dict row, Dict db_settings = null)
	{
		Helper helper = @.getDriver(classof Helper);
		
		/* Find builder */
		StructBuilder builder = helper.tables.get(object_name, null);
		if (builder == null)
		{
			return null;
		}
		
		/* Get filter */
		Collection<QueryFilter> filter = static::getPrimaryKey(object_name, pk)
			|> static::getFilter
		;
		
		/* Filter row */
		row = static::filterRow( object_name, row, "update" );
		
		/* To database */
		row = static::toDatabase( object_name, row, db_settings );
		
		/* Insert row */
		Cursor cursor = await static::update(builder.table_name, filter, row, db_settings);
		return cursor;
	}
	
	
	
	/**
	 * Delete object
	 */
	static async Cursor deleteObject(string object_name, Dict pk, Dict db_settings = null)
	{
		Helper helper = @.getDriver(classof Helper);
		
		/* Find builder */
		StructBuilder builder = helper.tables.get(object_name, null);
		if (builder == null)
		{
			return null;
		}
		
		/* Get filter */
		Collection<QueryFilter> filter = static::getPrimaryKey(object_name, pk)
			|> static::getFilter
		;
		
		/* Delete row */
		Cursor cursor = await static::delete(builder.table_name, filter, db_settings);
		return cursor;
	}
	
	
	
	/**
	 * Returns object by id
	 */
	static async Dict getById(string object_name, var id, Dict db_settings = null)
	{
		Collection<QueryFilter> filter = static::getPrimaryKeyById(object_name, id) |> static::getFilter;
		if (filter == null) return null;
		
		/* Execute query */
		Dict res = static::selectObjects(object_name)
			|> .filter(filter)
			|> .limit(1)
			|> await .one(db_settings)
		;
		
		return res;
	}
	
	
	
	/**
	 * Returns object by id
	 */
	static async Dict findById(string object_name, var id, Dict db_settings = null)
		=> await static::getById(object_name, id, db_settings);
	
	/*
	static async Dict findRecordById(string object_name, var id, Dict db_settings = null)
		=> await static::getById(object_name, id, db_settings);
	
	static async Dict getRecordById(string object_name, var id, Dict db_settings = null)
		=> await static::getById(object_name, id, db_settings);
	*/
	
	
	/**
	 * Returns object by key
	 */
	static async Dict getByKey(string object_name, Dict key, Dict db_settings = null)
	{
		Collection<QueryFilter> filter = static::getPrimaryKey(object_name, key) |> static::getFilter;
		if (filter == null) return null;
		
		/* Execute query */
		Dict res = static::selectObjects(object_name)
			|> .filter(filter)
			|> .limit(1)
			|> await .one(db_settings)
		;
		
		return res;
	}
	
	
	
	/**
	 * Returns filter from Dict
	 */
	pure Collection<QueryFilter> getFilter(Dict item)
	{
		if (item == null) return null;
		
		Vector res = new Vector();
		Collection keys = item.keys();
		for (int i = 0; i<keys.count(); i++)
		{
			string field_name = keys[i];
			res.pushValue
			(
				new QueryFilter
				{
					"field_name": field_name,
					"op": "=",
					"value": item[field_name],
				}
			);
		}
		
		return res.toCollection();
	}
	
	
	
	/**
	 * Returns primary key names
	 */
	pure Primary getPrimaryKeyAnnotation(string object_name)
	{
		Helper helper = @.getDriver(classof Helper);
		StructBuilder builder = helper.tables.get(object_name, null);
		if (builder != null)
		{
			Collection keys = builder.keys.filter( lib::isInstance(classof Primary) );
			Primary key = keys[0];
			return key;
		}
		return null;
	}
	
	
	
	/**
	 * Returns primary key from item
	 */
	pure Dict getPrimaryKey(string object_name, Dict item)
	{
		if (item == null) return null;
		Primary key = static::getPrimaryKeyAnnotation(object_name);
		if (key == null) return null;
		return item.toDict().intersect( key.keys );
	}
	
	
	
	/**
	 * Returns primary key by id
	 */
	pure Dict getPrimaryKeyById(string object_name, var id)
	{
		Primary key = static::getPrimaryKeyAnnotation(object_name);
		if (key == null) return null;
		
		Dict res = {};
		for (int i=0; i<key.keys.count(); i++)
		{
			string api_name = key.keys[i];
			res = res.setIm(api_name, id);
			break;
		}
		
		return res;
	}
	
	
	
	/**
	 * To database
	 */
	static Dict toDatabase(string object_name, Dict item, Dict db_settings = null)
	{
		return item;
	}
	
	
	
	/**
	 * From database
	 */
	static Dict fromDatabase(string object_name, Dict item, Dict db_settings = null)
	{
		return item;
	}
	
	
	
	/**
	 * To database field
	 */
	static Dict toDatabaseField(string object_name, string field_name, primitive value, Dict db_settings = null)
	{
		return value;
	}
	
	
	
	/**
	 * From database field
	 */
	static Dict fromDatabaseField(string object_name, string field_name, primitive value, Dict db_settings = null)
	{
		return value;
	}
}