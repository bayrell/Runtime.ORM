/*!
 *  BayLang Technology
 *
 *  (c) Copyright 2016-2024 "Ildar Bikmamatov" <support@bayrell.org>
 *
 *  Licensed under the Apache License, Version 2.0 (the "License");
 *  you may not use this file except in compliance with the License.
 *  You may obtain a copy of the License at
 *
 *      https://www.apache.org/licenses/LICENSE-2.0
 *
 *  Unless required by applicable law or agreed to in writing, software
 *  distributed under the License is distributed on an "AS IS" BASIS,
 *  WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 *  See the License for the specific language governing permissions and
 *  limitations under the License.
 */

namespace Runtime.ORM;

use Runtime.BaseObject;
use Runtime.ORM.Provider;


class Record<Relation> extends BaseObject
{
	protected Map _old_data = null;
	protected Map _new_data = new Map;
	protected Relation _relation = null;
	
	
	/**
	 * Create new Record
	 */
	void constructor(Map data, Relation relation)
	{
		parent();
		this._relation = relation;
		this._initData(data);
	}
	
	
	/**
	 * Returns relation
	 */
	Relation relation() => this._relation;
	
	
	/**
	 * Convert to Dict
	 */
	Map all() => this._new_data.copy();
	Map old() => this._old_data.copy();
	Map getData() => this._new_data.copy();
	Map intersect(Collection fields = null) => this._new_data.intersect(fields);
	
	
	/**
	 * Returns primary key
	 */
	public Map getPrimaryKey()
	{
		return this.relation.getPrimaryKey(this._new_data);
	}
	
	
	/**
	 * Returns value
	 */
	var get(string name, var def_value = null) => this._new_data.get(name, def_value);
	
	
	/**
	 * Set new value
	 */
	void set(string name, var value)
	{
		this._new_data.set(name, value);
	}
	
	
	/**
	 * Assign data
	 */
	void assign(Map data)
	{
		Vector keys = rtl::list(data.keys());
		for (int i=0; i<keys.count(); i++)
		{
			string key = keys.get(i);
			this.set(key, data.get(key));
		}
	}
	void setData(Dict item) => this.assign(item);
	
	
	/**
	 * Get updated data
	 */
	Map getUpdatedData()
	{
		if (this._new_data == null) return {};
		
		Map res = new Map;
		
		Collection new_data_keys = rtl::list(this._new_data.keys());
		for (int i=0; i<new_data_keys.count(); i++)
		{
			string field_name = new_data_keys[i];
			var new_value = this._new_data.get(field_name);
			
			if (this._old_data == null)
			{
				res.set(field_name, new_value);
			}
			else
			{
				if (not this._old_data.has(field_name))
				{
					res.set(field_name, new_value);
				}
				else
				{
					var old_value = this._old_data.get(field_name);
					if (new_value != old_value)
					{
						res.set(field_name, new_value);
					}
				}
			}
		}
		
		return res;
	}
	
	
	/**
	 * Init data
	 */
	void _initData(Dict data = null)
	{
		this._old_data = data != null ? new Map(data) : null;
		this._new_data = data != null ? new Map(data) : new Map();
	}
	
	
	/**
	 * Returns true if object is new
	 */
	bool isNew()
	{
		return this._old_data ? false : true;
	}
	
	
	/**
	 * Returns true if data has loaded from database
	 */
	bool isUpdate()
	{
		return this._old_data ? true : false;
	}
	
	
	/**
	 * Returns true if model is changed
	 */
	bool isChanged()
	{
		Dict d1 = this._old_data;
		Dict d2 = this._new_data;
		
		if (d1 == null) return true;
		if (d2 == null) return true;
		
		Collection d1_keys = d1.keys();
		Collection d2_keys = d2.keys();
		
		for (int i=0; i<d1_keys.count(); i++)
		{
			string key1 = d1_keys.get(i);
			
			if (not d2.has(key1))
			{
				return true;
			}
			
			var value1 = d1.get(key1);
			var value2 = d2.get(key1);
			
			if (value1 != value2)
			{
				return true;
			}
		}
		
		for (int i=0; i<d2_keys.count(); i++)
		{
			string key2 = d2_keys.get(i);
			
			if (not d1.has(key2))
			{
				return true;
			}
		}
		
		return false;
	}
	
	
	/**
	 * Save object
	 */
	async void save()
	{
		await this._relation.save(this);
	}
	
	
	/**
	 * Delete object
	 */
	async void delete()
	{
		await this._relation.delete(this);
	}
	
	
	/**
	 * Refresh object
	 */
	async void refresh()
	{
		await this._relation.refresh(this);
	}
	
	
	#ifcode PHP then
	
	/**
	 * Returns value
	 */
	function __get($key)
	{
		return $this->get($key);
	}
	
	
	/**
	 * Set value
	 */
	function __set($key, $value)
	{
		return $this->set($key, $value);
	}
	
	#endif
}