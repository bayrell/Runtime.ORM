/*!
 *  Bayrell Runtime Library
 *
 *  (c) Copyright 2018-2019 "Ildar Bikmamatov" <support@bayrell.org>
 *
 *  Licensed under the Apache License, Version 2.0 (the "License");
 *  you may not use this file except in compliance with the License.
 *  You may obtain a copy of the License at
 *
 *      https://www.apache.org/licenses/LICENSE-2.0
 *
 *  Unless required by applicable law or agreed to in writing, software
 *  distributed under the License is distributed on an "AS IS" BASIS,
 *  WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 *  See the License for the specific language governing permissions and
 *  limitations under the License.
 */

namespace Runtime.ORM;

use Runtime.CoreStruct;
use Runtime.ORM.DataProviderInterface;
use Runtime.ORM.OrmResult;


struct OrmQuery extends CoreStruct
{
	static const string QUERY_SELECT = "select";
	static const string QUERY_INSERT = "insert";
	static const string QUERY_UPDATE = "update";
	static const string QUERY_DELETE = "delete";
	static const string QUERY_INSERT_OR_UPDATE = "insert_or_update";
	
	Collection<string> fields = null;
	Collection<string> join = null;
	Dict<primitive> data = null;
	Dict<primitive> data_pk = null;
	Dict<primitive> data_insert = null;
	Dict<primitive> where_params = null;
	string kind = "";
	string where_str = "";
	string table_name = "";
	string table_name_alias = "";
	string model_name = "";
	string order_str = "";
	int calc_found_rows = 0;
	int start = 0;
	int limit = -1;
	bool flag_raw = false;
	bool flag_prefix = true;
	bool return_last_insert_id = false;
	bool as_model = false;
	
	
	
	/**
	 * As model
	 */
	lambda OrmQuery asModel(string model_name, bool as_model, OrmQuery q)
	{
		return q.copy({
			"model_name": model_name,
			"as_model": as_model,
		});
	}
	
	
	
	/**
	 * Select query
	 */
	lambda OrmQuery select(string table_name, Collection<string> fields, OrmQuery q)
	{
		if (fields == null) fields = ["*"];
		return q.copy({
			"kind": static::QUERY_SELECT,
			"table_name": table_name,
			"fields": fields,
		});
	}
	
	
	
	/**
	 * Insert query
	 */
	lambda OrmQuery insert(string table_name, OrmQuery q)
	{
		return q.copy({
			"kind": static::QUERY_INSERT,
			"table_name": table_name,
		});
	}
	
	
	
	/**
	 * Update query
	 */
	lambda OrmQuery update(string table_name, OrmQuery q)
	{
		return q.copy({
			"kind": static::QUERY_UPDATE,
			"table_name": table_name,
		});
	}
	
	
	
	/**
	 * Delete query
	 */
	lambda OrmQuery delete(string table_name, OrmQuery q)
	{
		return q.copy({
			"kind": static::QUERY_DELETE,
			"table_name": table_name,
		});
	}
	
	
	
	/**
	 * Insert or update query
	 */
	lambda OrmQuery insertOrUpdate(string table_name, OrmQuery q)
	{
		return q.copy({
			"kind": static::QUERY_INSERT_OR_UPDATE,
			"table_name": table_name,
		});
	}
	
	
	
	/**
	 * Set flag table prefix
	 */
	lambda OrmQuery prefix(bool flag, OrmQuery q)
	{
		return q.copy({ "flag_prefix": flag });
	}
	
	
	
	/**
	 * Set raw flag
	 */
	lambda OrmQuery raw(bool flag, OrmQuery q)
	{
		return q.copy({ "flag_raw": flag });
	}
	
	
	
	/**
	 * Add offset
	 */
	lambda OrmQuery offset(int page, int limit, OrmQuery q)
	{
		return q.copy({ "start": page * limit, "limit": limit });
	}
	
	
	
	/**
	 * Add order
	 */
	lambda OrmQuery order(string order, OrmQuery q)
	{
		return q.copy({ "order_str": order });
	}
	
	
	
	/**
	 * Add filter
	 */
	lambda OrmQuery where(string where, Dict params, OrmQuery q)
	{
		return q.copy({ "where_str": where, "where_params": params });
	}
	
	
	
	/**
	 * Add filter
	 */
	lambda OrmQuery filter(Dict filter, OrmQuery q)
	{
		string where_str = filter
			.keys()
			.map(string (string field_name) => field_name ~ "=:" ~ field_name)
			.join(" and ")
		;
		return q.copy({ "where_str": where_str, "where_params": filter });
	}
	
	
	
	/**
	 * Add values
	 */
	lambda OrmQuery values(Dict values, OrmQuery q)
	{
		return q.copy({ "data": values });
	}
	
	
	
	/**
	 * Add values
	 */
	lambda OrmQuery valuesPk(Dict values_pk, OrmQuery q)
	{
		return q.copy({ "data_pk": values_pk });
	}
	
	
	
	/**
	 * Add values
	 */
	lambda OrmQuery valuesInsert(Dict values_insert, OrmQuery q)
	{
		return q.copy({ "data_insert": values_insert });
	}
	
	
	
	/**
	 * Execute ORM
	 */
	static async OrmResult execute(DataProviderInterface provider, OrmQuery q)
	{
		OrmResult res = await provider->query(q);
		return res;
	}
	
	
	
	/**
	 * Execute ORM
	 */
	static async var fetchOne(DataProviderInterface provider, OrmQuery q)
	{
		OrmResult res = await provider->query(q);
		return res.items.get(0, null);
	}
}