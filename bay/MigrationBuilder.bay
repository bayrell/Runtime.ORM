/*!
 *  BayLang Technology
 *
 *  (c) Copyright 2016-2024 "Ildar Bikmamatov" <support@bayrell.org>
 *
 *  Licensed under the Apache License, Version 2.0 (the "License");
 *  you may not use this file except in compliance with the License.
 *  You may obtain a copy of the License at
 *
 *      https://www.apache.org/licenses/LICENSE-2.0
 *
 *  Unless required by applicable law or agreed to in writing, software
 *  distributed under the License is distributed on an "AS IS" BASIS,
 *  WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 *  See the License for the specific language governing permissions and
 *  limitations under the License.
 */

namespace Runtime.ORM;

use Runtime.lib;
use Runtime.BaseObject;
use Runtime.ORM.Annotations.Migration;
use Runtime.ORM.Factory.CursorFactory;
use Runtime.ORM.BaseMigration;
use Runtime.ORM.Connection;
use Runtime.ORM.Cursor;
use Runtime.ORM.Provider as DatabaseProvider;
use Runtime.ORM.QueryLog;


class MigrationBuilder extends BaseObject
{
	Connection connection = null;
	Collection<BaseMigration> migrations = null;
	bool execute = false;
	Dict version = {};
	Dict updated = {};
	
	
	/**
	 * Returns query log
	 */
	QueryLog getQueryLog() => this.connection.getQueryLog();
	
	
	/**
	 * Set branch versions
	 */
	void setVersion(Dict value)
	{
		if (not value) value = {};
		this.version = value;
	}
	
	
	/**
	 * Returns SQL query
	 */
	Collection<string> getSQL()
	{
		Collection<string> items = this.getQueryLog().map(lib::attr("sql"));
		Collection<string> result = [];
		
		for (int i=0; i<items.count(); i++)
		{
			string item = items.get(i);
			bool is_comment = rs::substr(item, 0, 2) == "--";
			if (is_comment)
			{
				if (i != 0) result.push("");
			}
			else
			{
				item ~= ";";
			}
			result.push(item);
		}
		
		return result;
	}
	
	
	/**
	 * Init migrations
	 */
	void init(string connection_name = "default")
	{
		/* Get database provider */
		DatabaseProvider database = @.provider(classof DatabaseProvider);
		
		/* Fork connection */
		this.connection = database.getConnection("default").fork();
		
		/* Set query log */
		this.connection.setQueryLog(new QueryLog);
		
		/* Execute migration */
		if (not this.execute)
		{
			this.connection.setCursorFactory(new CursorFactory(classof Cursor));
		}
		
		/* Get migrations */
		this.migrations = this.getMigrations();
	}
	
	
	/**
	 * Returns migrations
	 */
	Collection<BaseMigration> getMigrations()
	{
		Collection<Migration> items = @.getEntities(classof Migration);
		items = items.map(
			BaseMigration (Migration annotation) =>
				rtl::newInstance(annotation.name, [this.connection])
		);
		
		/* Make index */
		Dict<BaseMigration> index = {};
		for (int i=0; i<items.count(); i++)
		{
			BaseMigration item = items.get(i);
			index.set(item.getName(), item);
		}
		
		/* Add items */
		Collection migrations = [];
		Dict cache = {};
		
		fn addItem = null;
		addItem = void (BaseMigration item)
			use (migrations, cache, index, addItem)
		{
			if (item == null) return;
			if (cache.has(item.getName())) return;
			Collection<string> required = item.getRequired();
			required = required.map
			(
				BaseMigration (string name) use (index) => index.get(name)
			);
			required = required.filter(lib::equalNot(null));
			for (int i=0; i<required.count(); i++)
			{
				addItem(required.get(i));
			}
			if (not cache.has(item.getName()))
			{
				migrations.push(item);
			}
			cache.set(item.getName(), true);
		};
		
		for (int i=0; i<items.count(); i++)
		{
			addItem(items.get(i));
		}
		
		return items;
	}
	
	
	/**
	 * Check allow migration
	 * 0 - not allow
	 * 1 - allow
	 * 2 - next allow
	 */
	int allowMigration(BaseMigration migration, string kind)
	{
		string key = migration.getBranch()
		string value = migration.getName();
		string current_version = this.version.get(key);
		
		if (kind == "up")
		{
			if (this.updated.has(key)) return 1;
			if (current_version == "") return 1;
			if (value == current_version) return 2;
		}
		if (kind == "down")
		{
			if (this.updated.has(key)) return 1;
			if (current_version == "") return 0;
			if (value == current_version) return 1;
		}
		
		return 0;
	}
	
	
	/**
	 * Set current migration version
	 */
	void setCurrentMigration(int index)
	{
		BaseMigration migration = this.migrations.get(index);
		string key = migration.getBranch();
		string value = migration.getName();
		this.version.set(key, value);
		this.updated.set(key, value);
	}
	
	
	/**
	 * Set previous migration version
	 */
	void setPreviousMigration(int index)
	{
		BaseMigration migration = this.migrations.get(index);
		string key = migration.getBranch();
		string value = "";
		for (int i=index-1; i>=0; i--)
		{
			BaseMigration item = this.migrations.get(i);
			if (item.getBranch() == key)
			{
				value = item.getName();
				break;
			}
		}
		this.version.set(key, value);
		this.updated.set(key, value);
	}
	
	
	/**
	 * Up migrations
	 */
	async void up()
	{
		for (int i=0; i<this.migrations.count(); i++)
		{
			BaseMigration migration = this.migrations.get(i);
			
			/* Check allow migration */
			int allow = this.allowMigration(migration, "up");
			if (allow == 0) continue;
			
			/* Up migration */
			if (allow == 1)
			{
				await migration.up();
			}
			
			/* Set migration */
			this.setCurrentMigration(i);
		}
	}
	
	
	/**
	 * Down migrations
	 */
	async void down()
	{
		for (int i=this.migrations.count() - 1; i>=0; i--)
		{
			BaseMigration migration = this.migrations.get(i);
			
			/* Check allow migration */
			int allow = this.allowMigration(migration, "down");
			if (allow == 0) continue;
			
			/* Down */
			if (allow == 1)
			{
				await migration.down();
			}
			
			/* Set previous migration */
			this.setPreviousMigration(i);
		}
	}
}