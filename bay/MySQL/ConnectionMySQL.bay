/*!
 *  Bayrell Runtime Library
 *
 *  (c) Copyright 2016-2023 "Ildar Bikmamatov" <support@bayrell.org>
 *
 *  Licensed under the Apache License, Version 2.0 (the "License");
 *  you may not use this file except in compliance with the License.
 *  You may obtain a copy of the License at
 *
 *      https://www.apache.org/licenses/LICENSE-2.0
 *
 *  Unless required by applicable law or agreed to in writing, software
 *  distributed under the License is distributed on an "AS IS" BASIS,
 *  WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 *  See the License for the specific language governing permissions and
 *  limitations under the License.
 */

namespace Runtime.ORM.MySQL;

use Runtime.io;
use Runtime.ORM.Query;


class ConnectionMySQL extends Connection
{
	public string host = "";
	public string port = "";
	public string login = "";
	public string password = "";
	public string database = "";
	public string prefix = "";
	public string connect_error = "";	
	public var pdo = null;
	public bool is_transaction = false;
    
	
	/**
	 * Connect
	 */
	ConnectionMySQL connect()
	{
		this.connect_error = "";
        
		#ifcode PHP then
        
        try
		{
			$str = 'mysql:host='.$this->host;
			if ($this->port != null) $str .= ':'.$this->port;
			if ($this->database != null) $str .= ';dbname='.$this->database;
			$this->pdo = new \PDO(
				$str, $this->login, $this->password, 
				array(
					\PDO::ATTR_PERSISTENT => false
				)
			);
			$this->pdo->setAttribute(\PDO::ATTR_ERRMODE, \PDO::ERRMODE_EXCEPTION);
			$this->pdo->exec("set names utf8");
		}
		catch (\PDOException $e)
		{
			$this->connect_error = 'Failed connected to database!';
		}
		catch (\Excepion $e)
		{
			$this->connect_error = $e->getMessage();
		}
        
        #endif
        
		return this;
	}
	
	
	/**
	 * Connect
	 */
	bool isConnected()
	{
		return this.pdo != null;
	}
	
	
	/**
	 * Create new cursor
	 */
	CursorMySQL createCursor() => new CursorMySQL(this);
	
	
	/**
	 * Begin transaction
	 */
	async void beginTransaction()
	{
		#ifcode PHP then
		
		$this->pdo->beginTransaction();
		$this->is_transaction = true;
		
		#endif
	}
	
	
	/**
	 * Commit
	 */
	async void commit()
	{
		#ifcode PHP then
		
		if ($this->is_transaction)
		{
			$this->pdo->commit();
			$this->is_transaction = false;
		}
		
		#endif
	}
	
	
	/**
	 * rollBack
	 */
	async void rollBack()
	{
		#ifcode PHP then
		
		if ($this->is_transaction)
		{
			$this->pdo->rollBack();
			$this->is_transaction = false;
		}
		
		#endif
	}
	
	
	/**
	 * Execute sql query
	 */
	async Cursor executeSQL(string sql, Dict data = null, Dict params = null)
	{
		Cursor cursor = this.createCursor();
		
		bool is_debug = params["debug"] |> default bool false;
		if (is_debug)
		{
			string sql2 = static::getSQL(sql, data);
			io::print(sql);
		}
		
		await cursor.executeSQL(sql, data);
		
		return cursor;
	}
	
	
	/**
	 * Execute cursor
	 */
	async Cursor executeQuery(Query q, Dict params = null)
	{
		if (params == null) params = {};				
		if (q.is_debug) params <= debug <= true;
		
		list res = await this.buildQuery(q);
		
		if (res)
		{
			string sql = res[0];
			Dict data = res[1];
			
			return await this.executeSQL(sql, data, params);
		}
		
		return null;
	}
	
	

	/**
	 * Returns query sql
	 */
	async list buildQuery(Query q)
	{
		/* Select query */
		if ($q->_kind == Query::QUERY_SELECT)
		{
			$sql = "SELECT ";
			$params = $q->_params;
			
			/* Add found rows */
			if ($q->_calc_found_rows == true) $sql .= " SQL_CALC_FOUND_ROWS ";
			
			/* Add fields */
			if ($q->_fields != null) $sql .= implode(", ", $q->_fields);
			else $sql .= " * ";
			
			/* New line */
			$sql .= "\n";
			
			/* Add table name */
			$sql .= " FROM " . $this->prefix . $q->_table_name;
			
			/* Add table alias */
			if ($q->_table_name_alias != "") $sql .= " AS " . $q->_table_name_alias;
			
			/* New line */
			$sql .= "\n";
			
			/* Add joins */
			if ($q->_join != null)
			{
				foreach ($q->_join as $join)
				{
					$kind = $join["kind"];
					$table_name = $join["table_name"];
					$alias_name = $join["alias_name"];
					$where = $join["where"];
					
					if ($kind == "left") $sql .= " LEFT JOIN ";
					else $sql .= " INNER JOIN ";
					
					$sql .= $this->prefix . $table_name;
					if ($alias_name != "") $sql .= " AS " . $alias_name;
					$sql .= " ON (" . $where . ")";
					
					/* New line */
					$sql .= "\n";
				}
			}
			
			/* Add where */
			if ($q->_filter != null)
			{
				$res = $this->convertFilter($q->_filter);
				$where = $res[0];
				$params = array_merge($params, $res[1]);
				
				$where_str = implode(" AND ", $where);
				if ($where_str != "") $sql .= " WHERE " . $where_str;
				
				/* New line */
				$sql .= "\n";
			}
			
			/* Add order */
			if ($q->_order != null)
			{
				$order = array_map
				(
					function($item){ return $item[0] . " " . $item[1]; },
					$q->_order
				);
				
				$sql .= " ORDER BY " . implode(",", $order);
				
				/* New line */
				$sql .= "\n";
			}
			
			/* Add order */
			if ($q->_limit >= 0) $sql .= " LIMIT " . $q->_limit;
			if ($q->_limit >= 0 and $q->_start >= 0) $sql .= " OFFSET " . $q->_start;
			
			return [$sql, $params];
		}
		
		else if ($q->_kind == Query::QUERY_INSERT)
		{
			$keys = [];
			$values = [];
			foreach ($q->_values as $key => $val)
			{
				$keys[] = "`" . $key . "`";
				$values[] = ":" . $key;
			}
			
			/* Build sql */
			$sql = "insert into " . $q->_table_name . 
				" (" . implode(",",$keys) . ") values (" . implode(",",$values) . ")"
			;
			
			return [$sql, $q->_values];
		}
		
		else if ($q->_kind == Query::QUERY_UPDATE)
		{
			$args = [];
			
			/* Build update */
			$update_arr = [];
			foreach ($q->_values as $key => $value)
			{
				$update_arr[] = "`" . $key . "` = :_update_" . $key;
				$args["_update_" . $key] = $value;
			}
			$update_str = implode(", ", $update_arr);
			
			/* Build where */
			$res = $this->convertFilter($q->_filter);
			$where_str = implode(" AND ", $res[0]);
			$args = array_merge($args, $res[1]);
			
			/* Build sql */
			$sql = "update " . $q->_table_name . " set $update_str where $where_str";
			
			return [$sql, $args];
		}
		
		else if ($q->_kind == Query::QUERY_DELETE)
		{
			/* Build where */
			$res = $this->convertFilter($q->_filter);
			$where_str = implode(" AND ", $res[0]);
			$where_args = $res[1];
			
			/* Delete item */
			$sql = "delete from " . $q->_table_name . " where " . $where_str;
			
			return [$sql, $where_args];
		}
		
		else if ($q->_kind == Query::QUERY_RAW)
		{
			return [$q->_sql, $q->_params];
		}
		
		return null;
	}
	
	
	
	/**
	 * Convert filter
	 */
	function convertFilter($filter, $field_index = 0)
	{
		$params = [];
		$where = [];
		
		$convertKey = function($s)
		{
			return str_replace(".", "_", $s);
		};
		
		foreach ($filter as $item)
		{
			$field_name = $item[0];
			$op = $item[1];
			$value = $item[2];
			
			/* or */
			if ($field_name == "\$or")
			{
				if (is_array($op))
				{
					$arr_where = [];
					foreach ($op as $or)
					{
						list($where_or, $items_or, $field_index) =
							$this->convertFilter($or, $field_index)
						;
						$arr_where[] = implode(" AND ", $where_or);
						$params = array_merge($params, $items_or);
					}
					$where[] = "(" . implode(" OR ", $arr_where) . ")";
				}
				
				continue;
			}
			
			/* Check operation */
			if ( !in_array($op, ["=", "!=", ">=", "<=", "<", ">"]) )
			{
				$op = "=";
			}
			
			if (is_string($value) or is_int($value) or is_bool($value))
			{
				$field_key = $convertKey("where_" . $field_name . "_" . $field_index);
				$where[] = $this->escape($field_name) . " " . $op . " :" . $field_key;
				$params[$field_key] = $value;
				$field_index++;
			}
			
			else if (is_array($value))
			{
				$keys = [];
				foreach ($value as $v)
				{
					$field_key = $convertKey("where_" . $field_name . "_" . $field_index);
					$keys[] = ":" . $field_key;
					$params[$field_key] = $v;
					$field_index++;
				}
				$where[] = $this->escape($field_name) . " in (" . implode(",", $keys) . ")";
			}
			
			else if ($value === null)
			{
				if ($op == "!=") $where[] = $this->escape($field_name) . " is not null";
				else $where[] = $this->escape($field_name) . " is null";
			}
		}
		
		return [$where, $params, $field_index];
	}
}